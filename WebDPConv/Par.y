-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module WebDPConv.Par
  ( happyError
  , myLexer
  , pProg
  , pQuery
  , pDatasetId
  , pBudget
  , pStringList
  , pQueryStep
  , pDataType
  , pValue
  , pMParam
  , pNoiseM
  , pBinMap
  , pColumnSchema
  , pListQueryStep
  , pListString
  , pListColumnSchema
  , pListBinMap
  , pListValue
  , pListQuery
  ) where

import Prelude

import qualified WebDPConv.Abs
import WebDPConv.Lex

}

%name pProg Prog
%name pQuery Query
%name pDatasetId DatasetId
%name pBudget Budget
%name pStringList StringList
%name pQueryStep QueryStep
%name pDataType DataType
%name pValue Value
%name pMParam MParam
%name pNoiseM NoiseM
%name pBinMap BinMap
%name pColumnSchema ColumnSchema
%name pListQueryStep ListQueryStep
%name pListString ListString
%name pListColumnSchema ListColumnSchema
%name pListBinMap ListBinMap
%name pListValue ListValue
%name pListQuery ListQuery
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('       { PT _ (TS _ 1)  }
  ')'       { PT _ (TS _ 2)  }
  ','       { PT _ (TS _ 3)  }
  ';'       { PT _ (TS _ 4)  }
  '='       { PT _ (TS _ 5)  }
  'BIN'     { PT _ (TS _ 6)  }
  'Bool'    { PT _ (TS _ 7)  }
  'COUNT'   { PT _ (TS _ 8)  }
  'Double'  { PT _ (TS _ 9)  }
  'Enum'    { PT _ (TS _ 10) }
  'FILTER'  { PT _ (TS _ 11) }
  'Gauss'   { PT _ (TS _ 12) }
  'Int'     { PT _ (TS _ 13) }
  'Laplace' { PT _ (TS _ 14) }
  'MAP'     { PT _ (TS _ 15) }
  'MAX'     { PT _ (TS _ 16) }
  'MEAN'    { PT _ (TS _ 17) }
  'MIN'     { PT _ (TS _ 18) }
  'RENAME'  { PT _ (TS _ 19) }
  'SELECT'  { PT _ (TS _ 20) }
  'SUM'     { PT _ (TS _ 21) }
  'TO'      { PT _ (TS _ 22) }
  'Text'    { PT _ (TS _ 23) }
  '['       { PT _ (TS _ 24) }
  ']'       { PT _ (TS _ 25) }
  'false'   { PT _ (TS _ 26) }
  'true'    { PT _ (TS _ 27) }
  L_Ident   { PT _ (TV $$)   }
  L_doubl   { PT _ (TD $$)   }
  L_integ   { PT _ (TI $$)   }
  L_quoted  { PT _ (TL $$)   }

%%

Ident :: { WebDPConv.Abs.Ident }
Ident  : L_Ident { WebDPConv.Abs.Ident $1 }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Prog :: { WebDPConv.Abs.Prog }
Prog : ListQuery { WebDPConv.Abs.Program $1 }

Query :: { WebDPConv.Abs.Query }
Query
  : Ident DatasetId Budget '=' '(' ListQueryStep ')' { WebDPConv.Abs.Q $1 $2 $3 $6 }

DatasetId :: { WebDPConv.Abs.DatasetId }
DatasetId : Integer { WebDPConv.Abs.DId $1 }

Budget :: { WebDPConv.Abs.Budget }
Budget
  : Double { WebDPConv.Abs.PureDP $1 }
  | Double Double { WebDPConv.Abs.ApproxDP $1 $2 }

StringList :: { WebDPConv.Abs.StringList }
StringList : '[' ListString ']' { WebDPConv.Abs.Slist $2 }

QueryStep :: { WebDPConv.Abs.QueryStep }
QueryStep
  : 'SELECT' StringList { WebDPConv.Abs.QSelect $2 }
  | 'RENAME' StringList 'TO' StringList { WebDPConv.Abs.QRename $2 $4 }
  | 'FILTER' StringList { WebDPConv.Abs.QFilter $2 }
  | 'MAP' String '[' ListColumnSchema ']' { WebDPConv.Abs.QMap $2 $4 }
  | 'BIN' '[' ListBinMap ']' { WebDPConv.Abs.QBin $3 }
  | 'COUNT' MParam { WebDPConv.Abs.QCnt $2 }
  | 'MIN' MParam { WebDPConv.Abs.QMin $2 }
  | 'MAX' MParam { WebDPConv.Abs.QMax $2 }
  | 'SUM' MParam { WebDPConv.Abs.QSum $2 }
  | 'MEAN' MParam { WebDPConv.Abs.QMean $2 }

DataType :: { WebDPConv.Abs.DataType }
DataType
  : 'Bool' { WebDPConv.Abs.BType }
  | 'Int' Integer Integer { WebDPConv.Abs.IType $2 $3 }
  | 'Double' Double Double { WebDPConv.Abs.DType $2 $3 }
  | 'Text' { WebDPConv.Abs.TType }
  | 'Enum' StringList { WebDPConv.Abs.EType $2 }

Value :: { WebDPConv.Abs.Value }
Value
  : 'true' { WebDPConv.Abs.TVal }
  | 'false' { WebDPConv.Abs.FVal }
  | Integer { WebDPConv.Abs.IVal $1 }
  | Double { WebDPConv.Abs.DVal $1 }

MParam :: { WebDPConv.Abs.MParam }
MParam : String NoiseM Budget { WebDPConv.Abs.MParam $1 $2 $3 }

NoiseM :: { WebDPConv.Abs.NoiseM }
NoiseM
  : 'Gauss' { WebDPConv.Abs.GMech }
  | 'Laplace' { WebDPConv.Abs.LMech }

BinMap :: { WebDPConv.Abs.BinMap }
BinMap : String '[' ListValue ']' { WebDPConv.Abs.BMap $1 $3 }

ColumnSchema :: { WebDPConv.Abs.ColumnSchema }
ColumnSchema : String DataType { WebDPConv.Abs.CScheme $1 $2 }

ListQueryStep :: { [WebDPConv.Abs.QueryStep] }
ListQueryStep
  : {- empty -} { [] } | QueryStep ';' ListQueryStep { (:) $1 $3 }

ListString :: { [String] }
ListString
  : {- empty -} { [] }
  | String { (:[]) $1 }
  | String ',' ListString { (:) $1 $3 }

ListColumnSchema :: { [WebDPConv.Abs.ColumnSchema] }
ListColumnSchema
  : {- empty -} { [] }
  | ColumnSchema { (:[]) $1 }
  | ColumnSchema ',' ListColumnSchema { (:) $1 $3 }

ListBinMap :: { [WebDPConv.Abs.BinMap] }
ListBinMap
  : {- empty -} { [] }
  | BinMap { (:[]) $1 }
  | BinMap ',' ListBinMap { (:) $1 $3 }

ListValue :: { [WebDPConv.Abs.Value] }
ListValue
  : {- empty -} { [] }
  | Value { (:[]) $1 }
  | Value ',' ListValue { (:) $1 $3 }

ListQuery :: { [WebDPConv.Abs.Query] }
ListQuery : {- empty -} { [] } | Query ListQuery { (:) $1 $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

